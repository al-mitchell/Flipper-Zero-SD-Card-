I recommend checking out the abstract on [x86](https://github.com/RistBS/Awesome-RedTeam-Cheatsheet/edit/master/Binary%20Exploitation%20&%20Shellcoding/ASM/x86%20basics.md) before studying ARM.



### 1 - Registers

- **R0-R10** : General Purpose
- **R11**    : Frame Pointer (FP)
- **R12**    : Intra Procedural Call	
- **R13**    : Stack Pointer (SP)
- **R14**    : Link Register (LR)
- **R15**    : Program Counter/Instruction Pointer (PC)
- **CPSR**   : Current Program State Register/Flags	


#### 1.2 - CPSR

N | Z | C | V | Q | J | GE | E | A | I | F | T | M
--- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
Negative | Zero | Carry | overflow | underflow | Jazelle | Greater than or Equal for SIMD | Endianness | Abort disable | IRQ disable | FTQ disable | Thumb | processor mode (privilege mode) | 


### 2 - Hello world !

```asm
.text
.global _start
_start:
	    mov r0, #1
	    ldr r1, =message
	    ldr r2, =len
	    mov r7, #4
	    swi 0
	    mov r7, #1
	    swi 0
.data
message:
	    .asciz "Hello World !\n"
len = .-message
```
first by putting 1 in r0 for the standard output and we use **LDR (Load Register)** to load the value in the .data section to the specified registers. R7 is commonly used to hold Syscall Numbers like **4 for Write or 1 for Exit**. **SWI (Software Interrupt)** is used as the Syscall.

### 3 - Interact with ARM Syscalls

```asm
	area Example, CODE, READONLY
SWI_Exit EQU 0x11
SWI_Clock EQU 0x61
SWI_Open EQU 0x66
SWI_Close EQU 0x68
SWI_Write EQU 0x69
write_only EQU 4 
	entry

start   adr r0, filename
	mov r1, #write_only
     	swi SWI_Open
      	mov r5, r0
      	adr r1, String 
      	mov r2, #14 
      	swi SWI_Write
      	mov r0, r5
      	swi SWI_Close 
      	swi SWI_Exit
.data
        filename = "test.txt",0
        String = "Hello World!",&0a,&0d
	end
