


#### **1. Registers :**

![image](https://user-images.githubusercontent.com/75935486/152057010-ffd64c4f-8fa1-4f5f-8d24-280548268268.png)

```asm
rax = 64 BITS | eax = 32 BITS | ax = 16 BITS | ah = 8 BITS (higher byte) | al (lower byte)
rdi = 64 BITS | edx = 32 BITS | bx = 16 BITS | bh = 8 BITS (higher byte) | bl (lower byte)
rsi = 64 BITS | ecx = 32 BITS | cx = 16 BITS | ch = 8 BITS (higher byte) | cl (lower byte) 
rdx = 64 BITS | ebx = 32 BITS | dx = 16 BITS | dh = 8 BITS (higher byte) | dl (lower byte)
```
example:
```asm
EAX: 12 34 56 78
AX: 56 78
AH: 56
AL: 78
```

##### 1.2 - General Purpose registers :

- AX : accumulator
- BX : base (memory address)
- CX : counter
- DX : data
- SI : source index
- DI : destination index
- BP : base pointer
- SP : stack pointer



##### 1.3 - FLAGS :
Flags size are 1 bit.


- CS : code flag
- DS : data flag
- SS : stack flag
- ES : extra flag


#### **2. Sections :**

- .text : It's where we put our instructions.
- .data/.rodata – It's where we initialized data. 
- .bss – It's where there are uninitialized data. 

![image](https://user-images.githubusercontent.com/75935486/152057979-7f6a2028-b03f-4a7e-9058-3cb43960a1ee.png)



#### **3. How to define initialized and uninitialized data:**
To set initialized data:
- db = define bytes (1 bytes)
- dw = define word (2 bytes) 
- dd = define double word (4 bytes)
- dq = define quad word (8 bytes)
- dt = define ten bytes (10 bytes)

To set uninitialized data:
- resb = reserve bytes (1 bytes)
- resw = reserve word (2 bytes)
- resd =  reserve double word (4 bytes)
- resq = reserve quad words (8 bytes)
- rest = reserve ten bytes (10 bytes)

#### **4. Basic Instructions :**

- JMP: jump to a label
- CALL : call instructions
- MOV: 'destination', 'value' (If it's an Intel Syntax) - MOV 'source', 'destination' (If it's an AT&T syntax)
- MOVZX/MOVSX: MOVSX moves a signed value into a register and sign-extends it with 1. MOVZX moves an unsigned value into a register and zero-extends it with zero.
- SYSCALL: call kernel
- RET: return 
- INC: increment by 1
- DEC: decrement by 1
- LOOP: Set a loop. it's the equivalent of while in C.
- LEA: Load effective address. The lea instruction places the address specified by its first operand into the register specified by its second operand
- CMP: Compare two value. 

arithmetic operations:
- SUB : substraction
- ADD : addition 
- DIV ; division
- IDIV : signed division
- MUL/IMUL: imul multiplies signed numbers while mul multiplies unsigned numbers.



#### **5. Hello World ! : **

syscall table: https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md
```asm
BITS 64

global start ; to start the program to the label start

section .rodata
    hello db "Hello World !", 0xa, 0x0 ; The string "hello world" with 0xa. Oxa is the equivalent of \n in C in ASCII
    hello_lenght equ $-hello ; Count the number of bytes in our strings so we don't need to do it manually.
    
section .text ; the sections where we put our instructions

start: ; label start
      mov rax, 0x1         ; follow the syscall table write
      mov rdi, 0x1 
      mov rsi, hello       ; move the value of hello in rsi
      mov rdx, hello_lengh ; move the value of the lenght of the string in rdx
      syscall ; call the kernel
     
exit:
      mov rax, 0x3c ; 0x3c is 60 in hex. follow the syscall table exit 
      xor rdi, rdi ; zero out rdi.
      syscall ; call the kernel
```

###### 5.1 Compilation :
```
nasm -f elf64 -o hello.o hello.asm && ld -o hello hello.o
```

#### **6. Conditionnal Jumps**

- **JE** : jump if val1 is equal to val2 (|val1| = |val2|)
- **JA** : jump if val1 is above val2 (|val1| > |val2|)
- **JAE** : jump if val1 is above or equal to val2 (|val1| >= |val2|)
- **JB** : jump if val1 is below val2 (|val1| < |val2|)
- **JBE** : jump if val1 is below or equal to val2 (|val1| <= |val2|)
- **JG** : jump if val1 is greater than val2 (val1 > val2)
- **JGE** : jump if val1 is greater than or equal val2 (val1 >= val2)
- **JL** : jump if val1 is lower than val2 (val1 < val2)
- **JLE** : jump if val1 is lower than or equal val2 (val1 <= val2)


#### **7. loops:**

Loop in C =  `for (cx=0; cx<5; cx++){ ax = ax + cx }`, Equivalent in Assembly :

```asm
xor rax, rax 
xor rcx, rcx

boucle:
    cmp rcx, 0x5
    jge done
    add rax, rcx 
    inc rcx 
    jmp boucle 
done:
     mov rax, 0x3c
     xor rdi, rdi
     syscall
```
 We start by initializing the rax and rcx (counter) registers then we compare rcx to 5 with JGE (greater or equal) if it is the case we quit, if not we start the calculation
 and we increment of 1 with inc the counter and we make a jmp to repeat the instruction block.

#### 8. Stack:

- POP : pop a value from the stack
- PUSH : Push a value on the stack
- PUSHA : push the 8 general purpose registers on the stack
- POPA : pop the 8 general pupose registers from the stack

example :
```asm
mov rax, [rsp] ; RAX takes the first value at the top of the stack
mov rax, [rsp+2] ; RAX takes the second value at the top of the stack
mov rax, [rsp+3] ; RAX takes the third value at the top of the stack
```


###  Memory Segmentation Cheatsheet :

![image](https://user-images.githubusercontent.com/75935486/152057885-07742345-bef3-4793-85da-f631fe8101d5.png)
